1부 3장 : HTTP 메시지-3: 상태코드와 헤더

# 1. 상태코드
http 상태코드는 크게 다섯 가지로 나뉜다. 

<br/>

## 1. 100-199: 정보성 상태코드
HTTP/1.1에 도입되었다. 특히 100 Continue는 확인 작업을 최적화하기 위해 도입되었는데, 프로그래머를  혼란스럽게 하기도 한다.

| 상태코드 | 사유구절 | 설명 |
| --- | --- | --- |
| 100 | Continue |  시작 부분 일부가 받아들여졌고, 클라이언트는 나머지를 이어서 보내야 함. 이걸 보내면 서버는 반드시 요청을 받고 응답해야한다.  |
| 101 | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미. |

<br/>

### 100 continue에 대해

**왜 사용하나?**
클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전, 서버가 해당 본문을 받아들일 것인지 확인하고자 할 때 사용되며, 그 확인 작업을 최적화 하기 위해 도입되었다. - 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다.

만약 클라이언트가  엔터티를 서버에게 보내려 하고, 100 continue 응답을 기다린다면 , 클라이언트는 값을 ‘100 continue’로 하는 **Expect 요청 헤더**를 보내야 한다. 반대로, 서버에게 엔터티 보낼 것이 아닌데 100-continue Expect 헤더를 보내면 서버를 혼란에 빠뜨린다. 서버는 클라이언트가 이어서 엔터티를 보낼 것이라고 생각하게 되기 때문이다.

**주의할 점**
한편으로는, 100-continue값이 담긴 Expect 요청 헤더를 보낸 클라이언트는 서버가 100 continue로 응답해주어야만 엔터티를 보낸다면 적절하게 구현된 서버가 아니라면 무한정 기다려야 하기 때문에, 100-continue 응답을 보내주기를 막연히 기다리게 해서는 안된다. 일정 시간이 지나면 그냥 엔터티를 보내야한다.

추가적으로, 클라이언트 개발자는 잘못 짜여진 http 애플리케이션에 대비해서 예상하지 못한 100 continue 응답에도 대비해야 한다.

### 서버와 100 continue

서버는 절대로 100-continue 응답을 받기를 의도하지 않은 클라이언트(expect헤더에 100-continue값을 보내지 않은)에게 100 continue 상태 코드를 보내서는 안된다. (근데 몇몇 잘못 만들어진 서버가 그렇게 하기 때문에,, 클라이언트는 이에 대비해야 한다)

 서버가 100 continue 응답을 보내기 전, 엔터티 일부 혹은 전체를 수신했다면, 100 continue를 보낼 필요가 없다. 클라이언트는 이미 계속 전송하기로 결정했기 때문. 하지만 끝까지 다 읽은 후에는 그 요청에 대한 최종 응답은 보내야 한다.

만약 서버가 100 continue응답 받길 의도한 요청을 받고 나서, 엔터티 본문을 읽기 전에 요청을 끝내기로 결정했다면 ( 기타 에러 등의 이유로 ) 응답을 그냥 보내고 연결을 닫으면 안된다. 클라이언트는 응답을 받을 수 없게 된다 - 4장의 TCP 끊기와 리셋 에러부분 참고.

### 프락시와 100 continue

100-continue 응답 받길 의도한 클라이언트로부터 요청을 받은 프락시는 만약 다음 홉(next-hop) 서버가 HTTP/1.1을 따르거나 OR 어떤 버전을 다루는지 모를 경우, Expect 헤더를 포함시켜서 요청을 다음으로 전달해야 함. 만약 다음 홉의 서버가 1.1 이전 버전을 따른다면 417 Expectation Failed 에러로 응답해야 한다.

만약,  HTTP/1.1 이전 버전을 따르는 클라이언트를 대신하여 프락시가 Expect 헤더, 100-continue값을 요청에 포함시키기로 했다면, 프락시는 100-continue 응답을 클라이언트에게 전달하면 안된다.  무슨 뜻인지 모르기 때문.

그래서 다음 홉서버들에 대한 상태, http버전을 기억해 두는 것이 좋다.

<br/>
<br/>

## 2. 200-299 성공 상태코드

| 상태 코드 | 사유 구절 | 의미 |
| --- | --- | --- |
| 200 | OK | 요청은 정상, 응답의 엔터티 본문은 요청된 리소스를 포함하고 있음 |
| 201 | Created | 서버 개체를 생성하라는 요청에 대한 응답. 생성된 리소스에 대한 구체적 참조가 담긴 Location 헤더를 보내야 하며, 엔터티 본문에도 해당 리소스를 참조할 수 있는 url을 보내야한다. 서버는 상태코드를 보내기 전에 반드시 객체를 생성해야 한다. |
| 202 | Accepted | 요청이 받아들이기에 적법해 보인다는 의미. 따라서 요청은 받아 들여졌지만 서버가 이에 대한 어떤 동작을 수행하지 않았고, 요청에 대한 처리를 완료할 것인지에 대한 보장은 없다. |
| 203 | Non-Authoritative Information(비 권한정보) | 클라이언트와 서버사이에 있는 프록시에서 사용할 수 있는 상태코드. 프록시가 형식을 변환하거나 본문에 무언가를 추가한 경우, 상태코드를 203-Non-Authoritative Information으로 변경하여 클라이언트에게 알릴 수 있음. 하지만 이런 경우 기존의 상태코드(서버가 보낸)를 확인할 수 없다. |
| 204 | No Content | 응답 메시지는 헤더와 상태줄을 포함하지만, 엔터티 본문은 포함하지 않음. 주로 웹 브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용한다. ex) form을 새로고침 |
| 205 | Reset Content | 주로 브라우저를 위해 사용되는 코드. 현재 페이지에 있는 html form에 채워진 모든 값을 비우라고 말하는 코드. |
| 206 | Partial  Content  | 부분, 범위 요청이 성공했음을 알려줌 (클라이언트는 범위 헤더를 사용해서 문서의 특정 범위를 요청할 수 있다) 206 응답은 Content-Range와 Date 헤더를 반드시 포함해야 하며, Etag와 Content-location 중 하나의 헤더도 반드시 포함해야 하여 특정 부분만 전송하고 있음을 알려주어야 한다. |

<br/>
<br/>

## 3. 300-399: 리다이렉션 상태코드
만약 리소스가 다른 곳으로 이동되었다면, 클라이언트에게 해당 리소스가 옮겨졌고, 어디에서 찾을 수 있는지 알려주기 위해 리다이렉션 상태코드와 location 헤더를 보낼 수 있다.

리다이렉션 상태코드 중 일부는 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교하여 유효한지 확인하기 위해 사용된다. : ex) 해당 로컬 복사본이 여전히 최신인지 검사하고, 서버에서 수정되어 최신본이 아닌경우에 문서를 가져오라고 할 수 있다.(If-Modified-Since헤더 사용 - 설정된 날짜 이후 변한 것이 없으면 서버에서 콘텐츠를 보내지 않고 304 코드를 보낸다.) 

리다이렉션 상태코드를 포함한 응답을 전송할 때 리다이렉트 될 URL과 링크에 대한 설명을 같이 보내는 것이 좋다.

| 상태코드 | 사유구절 | 의미 |
| --- | --- | --- |
| 300 | Multiple Chocies | 클라이언트가 요청한 URL이 동시에 여러 리소스를 가리키는 경우, 그 리소스의 목록과 함께 반환함. ⇒ 사용자는 이 중 선택 가능. ex) 요청한 html문서가 영어, 프랑스어, 한국어 모두로 제공되는 경우 이런 여러 버전이 존재할 때 클라이언트 협상이 이루어지는데. 17장에서 자세히 다룬다. 서버는 Locaition헤더에 선호하는 URL을 포함시킬 수 있음. |
| 301 | Moved Permanently | 요청한 URL이 옮겨졌을 때 사용함. 응답에는 현재 리소스가 존재하고 있는 URL을 Location 헤더에 포함해야 한다. |
| 302 | Found |  301과 같지만 Moved Temporarily다. 클라이언트는 Location헤더에 담긴 url을 리소스를 임시로 가리키기 위한 목적으로 사용해야 함.  |
| 303 | See Other | 리소스를 다른 URL에서 GET 해야 한고 말해줌. 해당 URL은 Location 헤더에 있다. 주 목적은 POST 요청에 대한 응답으로 리소스의 위치를 알려주는 것. |
| 304 | Not Modified | 클라이언트가 조건부 요청(if-Modified-since)를 했을 때, 요청한 리소스가 최근에 수정된 적 없을 때 보내는 상태코드. 이 상태코드를 동반한 응답은 엔터티 본문을 가지면 안된다.클라이언트는 리소스가 수정되었을 때만 리소스를 원하기 때문. 수정되지 않았다면 클라 쪽에서 캐시된 리소스를 계속 사용함. |
| 305 | Use Proxy | 리소스가 반드시 프락시를 통해 접근되어야 함을 나타냄. 프락시 위치는 Location 헤더로 주어진다. 클라이언트는 모든 요청에 대해 이 프락시를 통해야 한다고 상정하지 않음. 오직 해당 리소스에 대한 것으로 간주함 (프락시가 요청에 잘못 간섭하면 오동작을 유발할 수 있고, 보안문제를 일으킬 수 있다.) - 지금은 보안문제로 사용하지 않음 |
| 306 | switch proxy → unused | 현재는 사용되지 않음. (보안상의 이유로). 다른 의미의 메시지가 이 코드를 사용하게 될 것임. |
| 307 | Temporary Redirect | 301 상태코드와 비슷하고, 302 Found 응답코드와 동일한 의미. 반드시 http 메소드를 변경하지 말아야 하는 점만 다름.클라이언트가 요청한 리소스가 다른 URI에 있으며, 이전 요청과 동일한 메소드를 사용하여 요청해야 할 때. 만약 첫 요청에 POST가 사용되었다면, 두 번째 요청도 반드시 POST를 사용해야 합니다. 

### 301 Moved Permanently VS 302 Found
> 둘은 겉보기에 비슷해보이지만 검색엔진의 관점에서 가장 큰 차이가 있습니다.
예를 들어 인기제품이 일시적으로 재고가 떨어져서 해당 제품의 페이지를 일시적으로 품절 페이지로 이동시키기 위해서는 둘 중 어떤 방식을 택해야 할까요? 
만일 301을 사용한다면 품절 페이지의 랭크가 올라갈 것이고 이는 쇼핑몰을 운영하는 입장에서 원하는 바가 아닙니다. 따라서 302를 통해 페이지는 리다이렉션하고 검색엔진은 인기제품의 랭크를 올릴 수 있도록 합니다.
출처
> 
> 
> [[WEB] HTTP 상태코드를 알아보자](https://ssungkang.tistory.com/entry/WEB-HTTP-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)
> 

### 302, 303, 307 상태코드
이 코드 모두 의미에서 중복되는 부분이 있다. 모두 클라이언트에게 리소스가 옮겨졌음을 알려주고, Location헤더로 해당 리소스를 가리키기 위한 url을 담아 보낸다. 하지만, 어떻게 사용되는가는 미묘하게 다르다.

**HTTP/1.0**
http/1.0클라이언트가 POST요청을 보내고 302 리다이렉트 상태 코드가 담긴 응답을 받으면, 클라이언트는 Location 헤더에 있는 리다이렉트 URL을 **GET** 요청으로 따라갈 것. 302 코드를 보낸 서버 또한 클라이언트가 GET 요청으로 해당 리소스를 따라갈 것이라고 예상한다.

**HTTP/1.1**
HTTP/1.1 에서는 위의 리다이렉션을 위해 303 상태코드를 사용한다. 
HTTP/1.1 명세가 나오면서 혼란이 나타났고, 이 혼란을 막기 위해, HTTP/1.1클라이언트에게는 일시적 리다이렉트를 위해 302 대신 307을 사용하게 하고, HTTP/1.0 클라이언트에게 302 코드를 보내도록 한다.
⇒ 결국 서버는 적절한 리다이렉트 상태코드를 보내기 위해서 클라이언트의 HTTP 버전을 검사해야한다...

<br/>
<br/>

## 4. 400-499: 클라이언트 에러 코드

 클라이언트가 잘못 구성된 요청 메시지를 보냈을 때 응답하는 코드. 
흔히 없는 URL에 대해 요청한 경우, 404 Not Found가 반환된다.
많은 클라이언트 에러는 브라우저에 의해 알아서 처리된다. 

| 상태코드 | 사유 구절 | 의미 |
| --- | --- | --- |
| 400 | Bad Request | 클라이언트가 잘못된 요청을 보냈음 |
| 401 | Unauthorized | 클라이언트에게 인증하라고 요구하는 응답 -이와 적절한 헤더와 함께 반환됨 |
| 402 | Payment Required | 현재 쓰이지는 않지만, 미래에 사용될 가능성이 있다. |
| 403 | Forbidden | 요청이 서버에 의해 거부됨. 왜 거부되었는지 설명하는 엔터티 본문을 포함할 수 있지만, 보통 거절 이유를 숨기고 싶을 때 사용한다. |
| 404 | Not Found | 요청한 URL을 찾을 수 없음.  |
| 405 | Method not Allowed | 요청한 URL에 대해 지원하지 않는 메소드로 요청했을 때 사용. Allow 헤더에 해당 리소스에 대해 어떤 메소드가 허용되는 지 꼭 알려주어야 한다. |
| 406 | Not Acceepted | 클라이언트는 어떤 종류의 엔터티 타입을 받고자 하는지 명시할 수 있는데, 요청한 URL 리소스 중 클라이언트가 받을 수 있는 것이 없는 경우 사용한다.  |
| 407 | Proxy Authentication Required | 401 Unauthorized 와 같지만, 리소스에 대해 인증을 요구하는 곳이 프락시임. |
| 408 | Request Timeout | 요청을 완수하는 데 시간이 너무 많이 걸리는 경우, 서버는 408 보내고 연결을 끊을 수 있다. 타임아웃 길이는 서버마다 다르지만, 대부분 어떤 요청도 받을 수 있을 정도로 길다. |
| 409 | Conflict | 요청 자체는 유효하지만, 요청이 리소스에 대해 충돌을 일으킬 수 있다고 판단될 때 이 요청을 보낸다. 다양한 경우가 있겠지만, 폴더에 파일을 추가하고자 할 경우 폴더가 존재하지 않을 때 적합하게 사용될 수 있다. 서버는 응답 본문에 충돌을 해결하기 위해 어떻게 해야하는지 알려주는 것이 권장됩니다. |
| 410 | Gone | 404와 비슷한데, 서버가 한 때 그 리소스를 갖고 있었다는 의미. 404는 애초에 존재하지 않는 url임을 알려주지만 410은 삭제된 리소스임을 알려줌 |
| 411 | Length Required | 요청 메시지에 “Content-Length”헤더가 있어야 함을 요구할 때 사용된다. |
| 412 | Precondition Failed | 조건부 요청을 받았는데, 그 중 하나가 실패했을 때 사용함. (조건부 요청은 클라이언트가 Expect 헤더를 포함하여 요청한 경우 발생) |
| 413 | Request Entity Too Large | 서버가 처리할 수 있는 / 처리하고자 하는 한계를 넘은 크기의 요청을 한 경우. |
| 414 | Request URI Too Long | 서버가 처리할 수 있는 / 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 경우. |
| 415 | Unsupported Media Type | 서버가 이해할 수 없거나 지원할 수 없는 내용의 유형 엔터티를 받았을 때. |
| 416 | Requested Range Not Satisfied | 리소스의 특정 범위(Range)를 요청했으나, 그 범위가 잘못되었을 때 |
| 417 | Expectation Failed | 요청의 Expect 헤더에 서버가 만족시킬 수 없는 조건이 담긴 경우. 프락시 또는 다른 중개자 애플리케이션이 판단하기에 원 서버가 해당 조건을 만족시킬 수 없다는 명확한 증거가 있을 때 이 응답코드를 전송할 수 있다. |

<br/>
<br/>

## 500-599: 서버 에러 상태코드
클라이언트가 적합한 요청을 보냈더라도, 서버 측에서 에러가 발생할 수 있다.
프락시는 클라이언트 입장에서 서버와 대화를 시도하는데, 이때 자주 에러를 만나게 되고, 해당 문제를 설명하기 위해 5XX 에러 상태코드를 생성한다.

<녹색 부분은 HTTP 완벽가이드 책에는 명시되지 않았지만 블로그에서 찾은 내용>

| 상태 코드 | 사유 구절 | 의미 |
| --- | --- | --- |
| 500 | Internal Server Error | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 |
| 501 | Not Implemented | 서버가 요청한 HTTP Method를 지원하지 않는 다는 점에서 405 Not Allowed 와 비슷하지만, 405 오류는 클라이언트 측에서 잘못 요청한 것이고, 501의 경우, 필요한 method인데 서버가 구현하지 않은 경우. |
| 502 | Bad Gateway |  프락시나 게이트웨이처럼 행동하는 서버가 해당 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답을 맞닥뜨렸을 때. |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 503 | Service Unavailable | 지금은 해당 요청을 처리할 수 없지만, 미래에 가능함을 의미.정확히 언제 해당 리소스를 사용할 수 있는지 알 때 ‘Retry-After’헤더를 포함시킨다. |
| 504 | Gateway Timeout | 408  Request Timeout 과 비슷하지만, 다른 서버에 요청을 보내고 응답을 기다리다 타임아웃이 발생한 곳이 게이트웨이 혹은 프락시이며, 이곳에서 온 응답이다. |
| 505 | HTTP Version Not supoorted | 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때. 대부분 1.0이전의 버전은 보안상의 이유로 사용하지 않으려고 함. |
| 507 | Insufficient Storage | 서버에 디스크 공간이 부족함 |
| 508 | Loop Detected | 요청을 처리하는 동안 무한 루프에 빠짐 |
| 510 | Not Extended | 요청에 대한 추가확장이 필요. - 클라이언트 에러에 더 적합하기 때문에 500대 에러에 있는 것이 부적합하여 사용되지 않음. |
| 511 | Network Authentication Required | 클라이언트가 네트워크 액세스를 얻기 위해 인증을 받아야 함. |

<aside>
💡 다음 편엔 헤더에 대해 알아보며 HTTP 메시지를 정리하겠습니다(진짜 끝)
</aside>
